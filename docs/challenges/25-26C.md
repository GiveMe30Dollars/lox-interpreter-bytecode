# 25-26C: Challenges from Chapters 25 to 26

## 25-1:

<blockquote>
Wrapping every ObjFunction in an ObjClosure introduces a level of indirection that has a performance cost. That cost isn’t necessary for functions that do not close over any variables, but it does let the runtime treat all calls uniformly.

Change clox to only wrap functions in ObjClosures that need upvalues. How does the code complexity and performance compare to always wrapping functions? Take care to benchmark programs that do and do not use closures. How should you weight the importance of each benchmark? If one gets slower and one faster, how do you decide what trade-off to make to choose an implementation strategy?
</blockquote>

See original solution: https://github.com/munificent/craftinginterpreters/blob/master/note/answers/chapter25_closures/1.md

I'm unsure as to whether I want to implement this. **Marked as Maybe?**

I come from C/Java-land where closures are Not A Thing. This probably would bias me into preferring the implementation that is more performant for non-closure functions. It's hard to see which approach would enable that, though, since function and closure objects are usually not spam-created at runtime ([pathological, huh?](https://github.com/munificent/craftinginterpreters/blob/master/note/answers/chapter25_closures/1.md)) and are instead reused across the codebase.

Generally:
- Function calls: mild performance hit.
- Non-closure creation: major performance boost.
- Closure creation: unaffected.

# 25-2:

<blockquote>
Read the design note below. I’ll wait. Now, how do you think Lox should behave? Change the implementation to create a new variable for each loop iteration.
</blockquote>

**Added.** Implementation details around break and continue are described in Document [04I](../internal/04I_LoopVariableClosure.md).
# 25-26C: Challenges from Chapters 25 to 26

## 25-1:

<blockquote>
Wrapping every ObjFunction in an ObjClosure introduces a level of indirection that has a performance cost. That cost isn’t necessary for functions that do not close over any variables, but it does let the runtime treat all calls uniformly.

Change clox to only wrap functions in ObjClosures that need upvalues. How does the code complexity and performance compare to always wrapping functions? Take care to benchmark programs that do and do not use closures. How should you weight the importance of each benchmark? If one gets slower and one faster, how do you decide what trade-off to make to choose an implementation strategy?
</blockquote>

See original solution: https://github.com/munificent/craftinginterpreters/blob/master/note/answers/chapter25_closures/1.md

I'm unsure as to whether I want to implement this.

I come from C/Java-land where closures are Not A Thing. This probably would bias me into preferring the implementation that is more performant for non-closure functions. It's hard to see which approach would enable that, though, since function and closure objects are usually not spam-created at runtime ([pathological, huh?](https://github.com/munificent/craftinginterpreters/blob/master/note/answers/chapter25_closures/1.md)) and are instead reused across the codebase.

Generally:
- Function calls: mild performance hit.
- Non-closure creation: major performance boost.
- Closure creation: unaffected.

**Update: added optional closures.**

Of course, the "pathological" testcase won out when it came to optional closures, but I was really interested in whether function calls would take a hit. I used the fibonacci testcase with `fib(40)`.

The results? Basically the same.

I'm pretty sure that I got an outlier value for one of these from running Firefox in the background, but for a best out of three, mandatory closures scored around 88.5 - *100.2* seconds, whereas optional closures scored 88.5 - 92.2 seconds.

That's... nothing. The conditional in `getFrameFunction` didn't impede performance for *shit*.

Keep in mind that while I am *not* going to model out the accurate number of function calls in `fib(40)`, if we naively assume each call to branch twice to `fib(n-1)`, that is an upper bound of *2<sup>40</sup> - 1 function calls.* Divide that number by 2 if we assume that the shorter left branch causes the function space to be cut in half. It doesn't really matter.

If *this* didn't cause function calls to take a performance hit, nothing will.

# 25-2:

<blockquote>
Read the design note below. I’ll wait. Now, how do you think Lox should behave? Change the implementation to create a new variable for each loop iteration.
</blockquote>

**Added.** Implementation details around break and continue are described in Document [04I](../internal/04I_LoopVariableClosure.md).
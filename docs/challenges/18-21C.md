# 16-21C: Challenges from Chapters 16 to 21

## 16:

<blockquote>
1. Each string requires two separate dynamic allocations—one for the ObjString and a second for the character array. Accessing the characters from a value requires two pointer indirections, which can be bad for performance. A more efficient solution relies on a technique called flexible array members. Use that to store the ObjString and its character array in a single contiguous allocation.

2. When we create the ObjString for each string literal, we copy the characters onto the heap. That way, when the string is later freed, we know it is safe to free the characters too.  
This is a simpler approach but wastes some memory, which might be a problem on very constrained devices. Instead, we could keep track of which ObjStrings own their character array and which are “constant strings” that just point back to the original source string or some other non-freeable location. Add support for this.

3. If Lox was your language, what would you have it do when a user tries to use + with one string operand and the other some other type? Justify your choice. What do other languages do?
</blockquote>

See original solution: https://github.com/munificent/craftinginterpreters/blob/master/note/answers/chapter19_strings.md

None of these are to be implemented.  
For `16-3`, the other type must be cast to a string before concatenation can be performed. String interpolation is to be supported natively.

## 17-1:

<blockquote>
In clox, we happen to only need keys that are strings, so the hash table we built is hardcoded for that key type. If we exposed hash tables to Lox users as a first-class collection, it would be useful to support different kinds of keys.

Add support for keys of the other primitive types: numbers, Booleans, and nil. Later, clox will support user-defined classes. If we want to support keys that are instances of those classes, what kind of complexity does that add?
</blockquote>

Support added. **TODO: add hash tables as first-class Lox objects.**

Any instance of a class must be hashed as unique entities; even if two instances have the same fields, their resultant hashes must be distinct. The easiest way to do this is to hash the *pointer value* of the instance.

## 17-2:

<blockquote>
Hash tables have a lot of knobs you can tweak that affect their performance. You decide whether to use separate chaining or open addressing. Depending on which fork in that road you take, you can tune how many entries are stored in each node, or the probing strategy you use. You control the hash function, load factor, and growth rate.

All of this variety wasn’t created just to give CS doctoral candidates something to publish theses on: each has its uses in the many varied domains and hardware scenarios where hashing comes into play. Look up a few hash table implementations in different open source systems, research the choices they made, and try to figure out why they did things that way.
</blockquote>

- Python:
  - Two arrays are maintained: a sparse array which implements the hashing and collision resolution, in which contains an index;  
  and a dense array containing the entries in chronological insertion order. This allows Python Dictionaries to maintain insertion order, as well as improve spatial efficiency.  
  (I assume that) tombstones are marked and cleared from the dense arrray during reallocation.
  - Open addressing, pseudo-random probing.    
  Further reading: https://stackoverflow.com/questions/327311/how-are-pythons-built-in-dictionaries-implemented

- Rust:
  - Open addressing, quadratic probing. SIMD hashing algorithm used.  
  Further reading: https://doc.rust-lang.org/std/collections/struct.HashMap.html

- C++:
  - `std::map`
    - Not actually a hash table.
    - Red-black tree (https://www.geeksforgeeks.org/introduction-to-red-black-tree/) allows for `O(lg N)` for amortized and worst-case insertion and deletion.
  - `std::unordered_map`
    - Separate chaining due to specification requirements:
      - Default load factor is `1.0`.
      - Iterators pointing into `std::unordered_map` elements must remain valid, even as elements are inserted or deleted.  
      See also: https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1456.html
    - `O(1)` amortized, `O(N)` worst-case.